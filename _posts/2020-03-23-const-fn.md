---
layout: post
title:  "const fn in Rust"
date:   2020-03-22 13:21:59 +0900
categories: Rust
---
Rust has a good language feature supporting the compile-time evaluation of function.

It is `const fn`.

At the time this post is written this feature is not in a state of stabilized, but you can use it using Nightly Rust compiler.

An example of `const fn` is below.

```rust
#![feature(const_fn)]
const fn to_selsius(x: i32) -> i32 {
    ((x as f64 - 32.0) / 1.8) as i32
}

const FAHR_75: i32 = 75;
const SELS_F75: i32 = to_selsius(FAHR_75);

fn main() {
    println!("75F equals {}C", SELS_F75);
}
```

As we can imagine, `const fn` functions run at compile-time, so there are no run-time costs to use this feature. It is similar to `constexpr` functions in C++.

If we need to define some constants which have complex expressions, it is a good chance to use it.

If we are using fixed-length objects like arrays and want to calculate the value related to the length of the array, it is also a good chance to use `const fn` because `Rust` compiler can determine all of the elements of an expression.

To use `const fn`, the function must be called in constants contexts and constant arguments.
In other words, the values of all elements of the expressions or statements must be determined at compile-time.
